<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Thinking...]]></title>
  <link href="http://kaihaodir.github.io/atom.xml" rel="self"/>
  <link href="http://kaihaodir.github.io/"/>
  <updated>2016-08-31T18:54:07+08:00</updated>
  <id>http://kaihaodir.github.io/</id>
  <author>
    <name><![CDATA[Kai]]></name>
    <email><![CDATA[kaihaodir@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIImagePNGRepresentation 保存图片时Crash]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/08/31/save-image-crash/"/>
    <updated>2016-08-31T17:37:11+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/08/31/save-image-crash</id>
    <content type="html"><![CDATA[<p>最近遇到一个保存图片时的崩溃， 崩溃信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0  CoreFoundation!__exceptionPreprocess + 0x84
</span><span class='line'>1  libobjc.A.dylib!objc_exception_throw + 0x38
</span><span class='line'>2  CoreFoundation!+[NSException raise:format:] + 0x7c
</span><span class='line'>3  Foundation!_NSMutableDataGrowBytes + 0x300
</span><span class='line'>4  Foundation!-[NSConcreteMutableData appendBytes:length:] + 0x174
</span><span class='line'>5  ImageIO!CGImageWriteSessionPutBytes + 0x94
</span><span class='line'>6  ImageIO!write_fn + 0x28
</span><span class='line'>7  ImageIO!png_write_chunk_data + 0x34
</span><span class='line'>8  ImageIO!_cg_png_write_complete_chunk + 0x40
</span><span class='line'>9  ImageIO!png_compress_IDAT + 0x160
</span><span class='line'>10 ImageIO!png_write_find_filter + 0xa80
</span><span class='line'>11 ImageIO!_cg_png_write_row + 0x300
</span><span class='line'>12 ImageIO!writeOnePng + 0x1358
</span><span class='line'>13 ImageIO!_CGImagePluginWritePNG + 0x90
</span><span class='line'>14 ImageIO!CGImageDestinationFinalize + 0x1e8
</span><span class='line'>15 UIKit!UIImagePNGRepresentation + 0x248
</span><span class='line'>16 MFAFImageCache addImage:forRequest:withAdditionalIdentifier:
</span></code></pre></td></tr></table></div></figure>


<!--MORE-->


<p>提示的异常信息是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Exception Name: NSMallocException
</span><span class='line'>Exception Reason: *** -[NSConcreteMutableData appendBytes:length:]: unable to allocate memory for length (1751849)</span></code></pre></td></tr></table></div></figure>


<p>查看一下调用函数, 主要调用如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *filePath = [FileModel getLocalFileName:kPhotosDirectory byUrl:[[request URL] absoluteString]];
</span><span class='line'> if (image) {
</span><span class='line'>     @try {
</span><span class='line'>         NSData *imageData = UIImagePNGRepresentation(image);
</span><span class='line'>         [imageData writeToFile:filePath atomically:YES];
</span><span class='line'>     } @catch (NSException *exception) {
</span><span class='line'>         MFLogError(@"ImageCache", @"save image error:%@", exception);
</span><span class='line'>     } @finally {
</span><span class='line'>         
</span><span class='line'>     }
</span><span class='line'> }
</span></code></pre></td></tr></table></div></figure>


<p>说明在执行 <code>NSData *imageData = UIImagePNGRepresentation(image)</code> 这个操作时，崩溃了。而且崩溃的原因是<strong>内存分配出错</strong>。 通常这种问题都是因为内存不足引起的。但是查看了一下log， 发现并没有 MemoryWarning 这句日志，<strong>说明程序还没来得及处理系统的内存警告就崩溃了</strong>。</p>

<p>根据这些现象猜测可能的原因
* 图片比较大
* 外层也许有个for循环，多次调用，导致临时对象没来得及马上释放</p>

<p>针对这两种猜测，作了相应的处理</p>

<h4>图片内容较大</h4>

<p>其实有 UIImage 对象的时候，说明图片已经可以正常展示，加载这张图片到内存暂时是没有问题的。但保存的时候又根据 UIImage 对象生成 NSData， 然后在通过NSData保存文件。 在NSData写入文件到释放前，内存里面其实有两份 图片 的数据， 一份是显示的， 一份是准备用来保存的NSData。 这样其实就是临时分配了一块大空间，如果可以减少临时对象的分配，直接读取UIImage的数据来存储就可以降低内存的使用。
通过查阅文档，发现Image IO 的库可以做到。</p>

<p>于是，保存函数改成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)saveImage:(UIImage *)image toFile:(NSString *)filePath
</span><span class='line'>{
</span><span class='line'>    if (!image.CGImage) {
</span><span class='line'>        return NO;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:filePath];
</span><span class='line'>    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(url, kUTTypePNG, 1, nil);
</span><span class='line'>    if (!destination) {
</span><span class='line'>        return NO;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    CGImageDestinationAddImage(destination, image.CGImage, nil);
</span><span class='line'>    CGImageDestinationFinalize(destination);
</span><span class='line'>    CFRelease(destination);
</span><span class='line'>    
</span><span class='line'>    return YES;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>临时对象没有马上释放</h4>

<p>这种情况比较好处理，就是因为加到 AutoReleasePool 的对象没有马上释放，必须要等下一次 RunLoop 循环才会清理。
这种问题可以加 @autoreleasepool{} 处理。
最后函数变成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)saveImage:(UIImage *)image toFile:(NSString *)filePath
</span><span class='line'>{
</span><span class='line'>    if (!image.CGImage) {
</span><span class='line'>        return NO;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>        CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:filePath];
</span><span class='line'>        CGImageDestinationRef destination = CGImageDestinationCreateWithURL(url, kUTTypePNG, 1, nil);
</span><span class='line'>        if (!destination) {
</span><span class='line'>            return NO;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        CGImageDestinationAddImage(destination, image.CGImage, nil);
</span><span class='line'>        CGImageDestinationFinalize(destination);
</span><span class='line'>        CFRelease(destination);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return YES;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>当然 @autoreleasepool 写在这里作用并不大， 应该要加在相应的for()循环里面。
因此定义一个宏，方便替换，只要把原来的 for 替换成 AutoRelease_for 就可以。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define AutoRelease_for(...) for(__VA_ARGS__) @autoreleasepool </span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程下通知响应函数Crash]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/08/13/mutithread-notification-crash/"/>
    <updated>2016-08-13T16:32:26+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/08/13/mutithread-notification-crash</id>
    <content type="html"><![CDATA[<p>今天发现一个老问题引起的崩溃，记录一下。</p>

<p>先有问题的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>@implementation LogicHandle
</span><span class='line'>
</span><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        [[NSNotificationCenter defaultCenter] addObserver:self
</span><span class='line'>                                                 selector:@selector(onNotification)
</span><span class='line'>                                                     name:@"kLogicNotification" object:nil];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    [[NSNotificationCenter defaultCenter] removeObserver:self];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)onNotification
</span><span class='line'>{
</span><span class='line'>    [self showLog];
</span><span class='line'>    [self showLog];
</span><span class='line'>    [self showLog];
</span><span class='line'>    [self showLog];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)showLog
</span><span class='line'>{
</span><span class='line'>  NSLog(@"%@", self);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>//Post通知代码
</span><span class='line'>- (void)postNotificationInBackground
</span><span class='line'>{
</span><span class='line'>    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
</span><span class='line'>        [[NSNotificationCenter defaultCenter] postNotificationName:kLogicNotification object:nil];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>常规的通知接收模型大致都是这样格式，但是这种方式在处理多线程的调用时会有问题。</p>

<p>由于PostNotification是在另一个线程的，所以 <code>onNotification</code> 也会在另一个线程执行。 这个时候很多人会认为是不是多线程访问对象引起的崩溃？那加个锁可以解决问题吗？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)onNotification
</span><span class='line'>{
</span><span class='line'>  @synchronized (self) {
</span><span class='line'>      xxx;
</span><span class='line'>      xxx;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>没错， 多线程访问数据时会有问题，但很明显这里只是输出一下 self， 并没有涉及到数据的修改，所以这种方式的加锁是不能解决问题的。</p>

<p>主要原因是当后台线程在执行 <code>onNotification</code> 方法的时候，执行到一半，其他线程把对象释放了。</p>

<h3>解决方法：</h3>

<ul>
<li>保证在同一线程发通知</li>
<li>如果要支持多线程调用，可以用 &ldquo;强引用&rdquo; 确保对象不被释放。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)mutithread_message
</span><span class='line'>{
</span><span class='line'>  __strong __typeof(self) strongSelf = self;
</span><span class='line'>  [strongSelf op];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>这种其实就是 block 里面常规的  weak-strong 的写法，只是很少会直接写到函数里面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hook __NSArrayM objectAtIndex Caush UIKeyboardTaskEntry Crash]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/06/08/hook-nsarraym-objectatindex-keyboard-crash/"/>
    <updated>2016-06-08T16:27:22+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/06/08/hook-nsarraym-objectatindex-keyboard-crash</id>
    <content type="html"><![CDATA[<h3>前题</h3>

<pre><code>为了统一处理数组越界的问题，我们 HOOK __NSArrayM 的 objectAtIndex: 方法
</code></pre>

<h3>问题：</h3>

<pre><code>在可以输入文字的页面，使用"英文"键盘输入，触发联想功能，然后切换到后台，再激活程序，随便点一下就会崩溃。
</code></pre>

<h3>崩溃堆栈：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) bt
</span><span class='line'>* thread #1: tid = 0xf9f0c, 0x0000000182aadb9c libobjc.A.dylib`objc_msgSend + 28, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x61746572847637e1)
</span><span class='line'>    frame #0: 0x0000000182aadb9c libobjc.A.dylib`objc_msgSend + 28
</span><span class='line'>    frame #1: 0x0000000182ab5288 libobjc.A.dylib`objc_object::sidetable_release(bool) + 220
</span><span class='line'>    frame #2: 0x0000000182edd8e8 libsystem_blocks.dylib`_Block_release + 156
</span><span class='line'>    frame #3: 0x0000000188f256b0 UIKit`-[UIKeyboardTaskEntry dealloc] + 44
</span><span class='line'>  * frame #4: 0x00000001000ba5dc KeyboardCrash`-[MethodsHooker myRelease](self=0x000000014df0c140, _cmd="release") + 308 at MethodsHooker.m:138
</span><span class='line'>    frame #5: 0x0000000182ab5ae8 libobjc.A.dylib`(anonymous namespace)::AutoreleasePoolPage::pop(void*) + 508
</span><span class='line'>    frame #6: 0x00000001833149fc CoreFoundation`_CFAutoreleasePoolPop + 28
</span><span class='line'>    frame #7: 0x00000001888549e4 UIKit`_prepareForCAFlush + 352
</span><span class='line'>    frame #8: 0x0000000188592fa4 UIKit`_UIApplicationHandleEventQueue + 4900
</span><span class='line'>    frame #9: 0x00000001833ed09c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
</span><span class='line'>    frame #10: 0x00000001833ecb30 CoreFoundation`__CFRunLoopDoSources0 + 540
</span><span class='line'>    frame #11: 0x00000001833ea830 CoreFoundation`__CFRunLoopRun + 724
</span><span class='line'>    frame #12: 0x0000000183314c50 CoreFoundation`CFRunLoopRunSpecific + 384
</span><span class='line'>    frame #13: 0x0000000184bfc088 GraphicsServices`GSEventRunModal + 180
</span><span class='line'>    frame #14: 0x00000001885fe088 UIKit`UIApplicationMain + 204
</span><span class='line'>    frame #15: 0x00000001000ba73c KeyboardCrash`main(argc=1, argv=0x000000016fd4baf8) + 124 at main.m:14
</span><span class='line'>    frame #16: 0x0000000182eb28b8 libdyld.dylib`start + 4</span></code></pre></td></tr></table></div></figure>


<p>设置<strong>异常断点</strong>和<strong>Enable Zombie Objects</strong>后，可以看到以下异常信息：</p>

<blockquote><p>2016-06-08 16:50:12.430 KeyboardCrash[1487:1026067] *** -[UIKeyboardLayoutStar release]: message sent to deallocated instance 0x1580b6600</p></blockquote>

<p>主要是因为<code>UIKeyboardLayoutStar</code>对象已销毁了，但还有人调用 <code>-[UIKeyboardLayoutStar release]</code> 引起的。</p>

<h2>分析过程</h2>

<ul>
<li>新实现的方法</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)mySelfMutableObjectAtIndex:(NSUInteger)index
</span><span class='line'>{
</span><span class='line'>    
</span><span class='line'>    NSArray *array = (NSArray *)self;
</span><span class='line'>    if (array.count &lt;= index) {
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return [self originalMutableObjectAtIndex:index];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>函数逻辑比较简单，应该不会有什么问题。于是我又把判断条件去掉，改成这样</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)mySelfMutableObjectAtIndex:(NSUInteger)index
</span><span class='line'>{   
</span><span class='line'>    return [self originalMutableObjectAtIndex:index];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>奇怪的发现，问题居然没有出现了。那为什么加了判断条件会有问题，到底这两个函数有什么不一样呢？</p>

<p>于是反汇编对比了一下</p>

<p><strong>没加判断条件的汇编代码:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>KeyboardCrash`-[MethodsHooker mySelfMutableObjectAtIndex:]:
</span><span class='line'>    0x1000c624c &lt;+0&gt;:  stp    x29, x30, [sp, #-16]!
</span><span class='line'>    0x1000c6250 &lt;+4&gt;:  mov    x29, sp
</span><span class='line'>    0x1000c6254 &lt;+8&gt;:  sub    sp, sp, #32               ; =32 
</span><span class='line'>    0x1000c6258 &lt;+12&gt;: adrp   x8, 3
</span><span class='line'>    0x1000c625c &lt;+16&gt;: add    x8, x8, #216              ; =216 
</span><span class='line'>    0x1000c6260 &lt;+20&gt;: stur   x0, [x29, #-8]
</span><span class='line'>    0x1000c6264 &lt;+24&gt;: str    x1, [sp, #16]
</span><span class='line'>    0x1000c6268 &lt;+28&gt;: str    x2, [sp, #8]
</span><span class='line'>-&gt;  0x1000c626c &lt;+32&gt;: ldur   x0, [x29, #-8]
</span><span class='line'>    0x1000c6270 &lt;+36&gt;: ldr    x2, [sp, #8]
</span><span class='line'>    0x1000c6274 &lt;+40&gt;: ldr    x1, [x8]
</span><span class='line'>    0x1000c6278 &lt;+44&gt;: bl     0x1000c684c               ; symbol stub for: objc_msgSend
</span><span class='line'>    0x1000c627c &lt;+48&gt;: mov    sp, x29
</span><span class='line'>    0x1000c6280 &lt;+52&gt;: ldp    x29, x30, [sp], #16
</span><span class='line'>    0x1000c6284 &lt;+56&gt;: ret    </span></code></pre></td></tr></table></div></figure>


<p><strong>加了判断的汇编代码：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) dis
</span><span class='line'>KeyboardCrash`-[MethodsHooker mySelfMutableObjectAtIndex:]:
</span><span class='line'>    0x1000ca1c8 &lt;+0&gt;:   stp    x29, x30, [sp, #-16]!
</span><span class='line'>    0x1000ca1cc &lt;+4&gt;:   mov    x29, sp
</span><span class='line'>    0x1000ca1d0 &lt;+8&gt;:   sub    sp, sp, #48               ; =48 
</span><span class='line'>    0x1000ca1d4 &lt;+12&gt;:  stur   x0, [x29, #-16]
</span><span class='line'>    0x1000ca1d8 &lt;+16&gt;:  str    x1, [sp, #24]
</span><span class='line'>    0x1000ca1dc &lt;+20&gt;:  str    x2, [sp, #16]
</span><span class='line'>-&gt;  0x1000ca1e0 &lt;+24&gt;:  ldur   x0, [x29, #-16]
</span><span class='line'>    0x1000ca1e4 &lt;+28&gt;:  bl     0x1000ca854               ; symbol stub for: objc_retain
</span><span class='line'>    0x1000ca1e8 &lt;+32&gt;:  adrp   x1, 3
</span><span class='line'>    0x1000ca1ec &lt;+36&gt;:  add    x1, x1, #256              ; =256 
</span><span class='line'>    0x1000ca1f0 &lt;+40&gt;:  str    x0, [sp, #8]
</span><span class='line'>    0x1000ca1f4 &lt;+44&gt;:  ldr    x0, [sp, #8]
</span><span class='line'>    0x1000ca1f8 &lt;+48&gt;:  ldr    x1, [x1]
</span><span class='line'>    0x1000ca1fc &lt;+52&gt;:  bl     0x1000ca830               ; symbol stub for: objc_msgSend
</span><span class='line'>    0x1000ca200 &lt;+56&gt;:  ldr    x1, [sp, #16]
</span><span class='line'>    0x1000ca204 &lt;+60&gt;:  cmp    x0, x1
</span><span class='line'>    0x1000ca208 &lt;+64&gt;:  b.hi   0x1000ca220               ; &lt;+88&gt; at MethodsHooker.m:60
</span><span class='line'>    0x1000ca20c &lt;+68&gt;:  orr    w8, wzr, #0x1
</span><span class='line'>    0x1000ca210 &lt;+72&gt;:  movz   x9, #0
</span><span class='line'>    0x1000ca214 &lt;+76&gt;:  stur   x9, [x29, #-8]
</span><span class='line'>    0x1000ca218 &lt;+80&gt;:  str    w8, [sp, #4]
</span><span class='line'>    0x1000ca21c &lt;+84&gt;:  b      0x1000ca250               ; &lt;+136&gt; at MethodsHooker.m:63
</span><span class='line'>    0x1000ca220 &lt;+88&gt;:  adrp   x8, 3
</span><span class='line'>    0x1000ca224 &lt;+92&gt;:  add    x8, x8, #224              ; =224 
</span><span class='line'>    0x1000ca228 &lt;+96&gt;:  ldur   x9, [x29, #-16]
</span><span class='line'>    0x1000ca22c &lt;+100&gt;: ldr    x2, [sp, #16]
</span><span class='line'>    0x1000ca230 &lt;+104&gt;: ldr    x1, [x8]
</span><span class='line'>    0x1000ca234 &lt;+108&gt;: mov    x0, x9
</span><span class='line'>    0x1000ca238 &lt;+112&gt;: bl     0x1000ca830               ; symbol stub for: objc_msgSend
</span><span class='line'>    0x1000ca23c &lt;+116&gt;: mov    x29, x29
</span><span class='line'>    0x1000ca240 &lt;+120&gt;: bl     0x1000ca860               ; symbol stub for: objc_retainAutoreleasedReturnValue
</span><span class='line'>    0x1000ca244 &lt;+124&gt;: orr    w10, wzr, #0x1
</span><span class='line'>    0x1000ca248 &lt;+128&gt;: stur   x0, [x29, #-8]
</span><span class='line'>    0x1000ca24c &lt;+132&gt;: str    w10, [sp, #4]
</span><span class='line'>    0x1000ca250 &lt;+136&gt;: add    x0, sp, #8                ; =8 
</span><span class='line'>    0x1000ca254 &lt;+140&gt;: movz   x1, #0
</span><span class='line'>    0x1000ca258 &lt;+144&gt;: bl     0x1000ca86c               ; symbol stub for: objc_storeStrong
</span><span class='line'>    0x1000ca25c &lt;+148&gt;: ldur   x0, [x29, #-8]
</span><span class='line'>    0x1000ca260 &lt;+152&gt;: mov    sp, x29
</span><span class='line'>    0x1000ca264 &lt;+156&gt;: ldp    x29, x30, [sp], #16
</span><span class='line'>    0x1000ca268 &lt;+160&gt;: b      0x1000ca80c               ; symbol stub for: objc_autoreleaseReturnValue
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>可以看到， 添加了几句判断语句后， 编译器会帮我们添加了一些 objc_retain, objc_storeStrong(release), 和 objc_autoreleaseReturnValue 控制引用计数的函数。
而在函数最后返回的时候是调用了  objc_autoreleaseReturnValue 这个函数。</p>

<p>为了更好的观察 <code>UIKeyboardLayoutStar</code> 对象的引用技术变化， 我HOOK了 <code>NSObject</code> 的 <code>retain</code>, <code>release</code>, <code>autorelease</code> 函数， 并且把当前的引用计数（<code>retainCount</code>）打印出来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LLDB Command]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/06/03/lldb-command/"/>
    <updated>2016-06-03T16:36:26+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/06/03/lldb-command</id>
    <content type="html"><![CDATA[<h3>设置断点：</h3>

<ul>
<li><p>对所有C函数 functionA 设置断点</p>

<ul>
<li><p>breakpoint set &ndash;name functionnameA &ndash;name functionNameB</p></li>
<li><p>br s -n functionA</p></li>
<li><p>b functionA</p></li>
</ul>
</li>
</ul>


<!--MORE-->


<ul>
<li><p>对FileA文件的LineNum行设置断点</p>

<ul>
<li><p>breakpoint set &ndash;file FileA &ndash;line LineNumber</p></li>
<li><p>b fileA:LineNumber</p></li>
</ul>
</li>
<li><p>C++ 函数， 对所有C++ 的 foo 函数设置断点</p>

<ul>
<li><p>breakpoint set &ndash;method foo</p></li>
<li><p>br s -M foo</p></li>
</ul>
</li>
<li><p>OC 对所有 aSelector 设置断点</p>

<ul>
<li><p>breakpoint set &ndash;selector aSelector</p></li>
<li><p>br s -S aSelectro</p></li>
</ul>
</li>
<li><p>设置 [NSString stringWithFormat] 断点</p>

<ul>
<li><p>breakpoint set &ndash;name &ldquo;-[NSString stringWithFormat:]&rdquo; (也是通过name的方式)</p></li>
<li><p>b -[NSString stringWithFormat:]</p></li>
</ul>
</li>
<li><p>可以添加 &ndash;shlib xxx.lib 来限制只设置这个模块的断点</p>

<ul>
<li><p>breakpoint set &ndash;name functionA &ndash;shlib foo.dylib</p></li>
<li><p>breakpoint set -n functionA -s foo.dylib</p></li>
</ul>
</li>
<li><p>设置条件断点</p>

<ul>
<li>breakpoint modify -c &lsquo;i == 10&rsquo;</li>
</ul>
</li>
<li><p>命中n次后停止</p>

<ul>
<li>breakpoint modify -i n</li>
</ul>
</li>
<li><p>当开始执行某个queue的时候停止</p>

<ul>
<li>breakpoint modify -q &lsquo;queue.name&rsquo;</li>
</ul>
</li>
<li><p>显不所有断点</p>

<ul>
<li><p>breakpoint list</p></li>
<li><p>br l</p></li>
</ul>
</li>
<li><p>删除断点</p>

<ul>
<li><p>breakpoint delete 1.1</p></li>
<li><p>br del 1.1</p></li>
</ul>
</li>
<li><p>添加命令</p>

<ul>
<li><p> (lldb) breakpoint command add 1.1</p></li>
<li><p>Enter your debugger command(s). Type &lsquo;DONE&rsquo; to end.</p></li>
<li><p>bt</p></li>
<li><p>DONE</p></li>
</ul>
</li>
</ul>


<h3>WatchPoint</h3>

<ul>
<li><p>当变量值改变时触发断点</p>

<ul>
<li>(lldb) watch set var global</li>
</ul>
</li>
<li><p>添加条件,(当值改为5时才触发)</p>

<ul>
<li>(lldb) watch modify -c &lsquo;global == 5&rsquo;</li>
</ul>
</li>
<li><p>当指针指向的地址内存数据发生变化时触发</p>

<ul>
<li><p>watchpoint set expression &ndash; myptr</p></li>
<li><p>wa s e &ndash; myptr</p></li>
<li><p>如果没有指定 -x byte_size ，默认观察指针大小的区域</p></li>
</ul>
</li>
</ul>


<h3>流程控制</h3>

<ul>
<li><p>代码级别单步执行</p>

<ul>
<li>step</li>
</ul>
</li>
<li><p>代码级别执行洗一条语句</p>

<ul>
<li>next</li>
</ul>
</li>
<li><p>指令级别单步</p>

<ul>
<li>stepi</li>
</ul>
</li>
<li><p>指定级别执行下一条指令</p>

<ul>
<li>nexti</li>
</ul>
</li>
<li><p>跳出当前帧函数</p>

<ul>
<li>finish</li>
</ul>
</li>
</ul>


<h3>查看变量</h3>

<ul>
<li><p>查看当前堆栈</p>

<ul>
<li><p>thread backtrace</p></li>
<li><p>bt</p></li>
</ul>
</li>
<li><p>切换当前堆栈帧</p>

<ul>
<li>frame select 3</li>
</ul>
</li>
<li><p>显示当前栈帧的参数和局部变量信息</p>

<ul>
<li>frame var -A</li>
</ul>
</li>
<li><p>以16进制的格式，显示当前栈局部变量的值</p>

<ul>
<li><p>frame variable &ndash;format x bar</p></li>
<li><p>f v -f x bar</p></li>
</ul>
</li>
<li><p>显不当前文件的全局变量/静态变量</p>

<ul>
<li><p>target var</p></li>
<li><p>ta var</p></li>
</ul>
</li>
</ul>


<h3>执行表达式</h3>

<ul>
<li><p>expr (int) printf (&ldquo;Print nine: %d.&rdquo;, 4 + 5)</p></li>
<li><p>expr unsigned int $foo = 5</p></li>
<li><p>调试状态下刷新界面</p>

<p>  ﻿* e (void)[CATransation flush]</p></li>
</ul>


<h3>查看内存</h3>

<ul>
<li><p>( lldb ) memory read &ndash;format x &ndash;size 4 0xbffff3c0</p>

<ul>
<li>以16进制格式显示0xbffff3c0开始的内存数据，数据是4个字节为一个单位的</li>
</ul>
</li>
<li><p>(lldb)memory read &ndash;outfile /tmp/mem.bin &ndash;binary 0x1000 0x1200</p>

<ul>
<li>把0x100 到 0x1200的内存数据输出到文件</li>
</ul>
</li>
</ul>


<h3>修改内存</h3>

<ul>
<li><p>在bytes+1的地方写入一个字节的数据：10</p>

<ul>
<li>memory write &lsquo;bytes + 1&rsquo; 10</li>
</ul>
</li>
<li><p>在bytes+1的地方写入大小为4字节的数据</p>

<ul>
<li>memory write -s 4 &lsquo;byte + 1&rsquo; 15</li>
</ul>
</li>
<li><p>在bytes开始的8个字节写入1，2，3，4。每个数据2字节</p>

<ul>
<li>memory write -s 2 &lsquo;byte&rsquo; 1 2 3 4</li>
</ul>
</li>
</ul>


<h3>寄存器</h3>

<ul>
<li><p>查看寄存器数据</p>

<ul>
<li>register read</li>
</ul>
</li>
<li><p>指定格式查看寄存器内容</p>

<ul>
<li><p>register read &ndash;format x</p></li>
<li><p>help format 可以查看相应的格式</p></li>
</ul>
</li>
<li><p>修改寄存器数据</p>

<ul>
<li><p>register write rax 123</p></li>
<li><p>register write pc &lsquo;$pc + 8&rsquo;</p></li>
</ul>
</li>
<li><p>函数调用约定，返回值放在r0，前面3个参数放在r1 ~ r3 里面</p></li>
</ul>


<h3>汇编</h3>

<ul>
<li><p>显示当前函数汇编代码</p>

<ul>
<li><p>disassemble &ndash;frame</p></li>
<li><p>dis -f</p></li>
</ul>
</li>
<li><p>显示指定函数名的汇编代码</p>

<ul>
<li><p>disassemble &ndash;name main</p></li>
<li><p>dis -n main</p></li>
</ul>
</li>
<li><p>显示指定地址范围的汇编代码</p>

<ul>
<li>disassemble &ndash;start-address 0x1eb8 &ndash;end-address 0x1ec3</li>
</ul>
</li>
<li><p>显示当前行的汇编代码</p>

<ul>
<li><p>disassemble &ndash;line</p></li>
<li><p>dis -l</p></li>
</ul>
</li>
<li><p>源代码和汇编代码混合显示</p>

<ul>
<li><p>disassemble  &ndash;frame &ndash;mixed</p></li>
<li><p>dis -f -m</p></li>
</ul>
</li>
<li><p>显示16进制opcode</p>

<ul>
<li>disassemble &ndash;frame &ndash;bytes</li>
</ul>
</li>
</ul>


<h3>其他</h3>

<ul>
<li><p>初始化时会读配置文件</p>

<ul>
<li>~/.lldbinit</li>
</ul>
</li>
<li><p>可指定别名</p>

<ol>
<li>(lldb) command alias bfl breakpoint set -f %1 -l %2</li>
<li>(lldb) bfl foo.c 12</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[找出引起异常的文字]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/05/25/debugfindcrashtext/"/>
    <updated>2016-05-25T00:23:23+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/05/25/debugfindcrashtext</id>
    <content type="html"><![CDATA[<p>大家可能都遇到过，一些比较特殊的字符，在排版的时候，或者在渲染的时候，会抛出异常。
当我们调试的时候，加了异常断点，就会触发断点。
这次主要是记录一下，当出现这种异常的时候，怎样把引起这个异常的文字找出来。</p>

<p>我们先看一下出现这种异常时的堆栈信息</p>

<!--MORE-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) bt
</span><span class='line'>* thread #1: tid = 0x70ed65, 0x0000000118914c6b libc++abi.dylib`__cxa_throw, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1
</span><span class='line'>    frame #0: 0x0000000118914c6b libc++abi.dylib`__cxa_throw
</span><span class='line'>    frame #1: 0x00000001311c782f libType1Scaler.dylib`TType1LWFNMultipleMasterHFMXTable::TType1LWFNMultipleMasterHFMXTable(TFontObjectSurrogate const&, int, short, short, int*) + 121
</span><span class='line'>    frame #2: 0x00000001311c7756 libType1Scaler.dylib`TType1LWFNFont::CreateHFMXTable() const + 86
</span><span class='line'>    frame #3: 0x00000001311c76f5 libType1Scaler.dylib`TType1HFMXTableSurrogate::TType1HFMXTableSurrogate(TType1PSFont const&) + 31
</span><span class='line'>    frame #4: 0x00000001311c6ec9 libType1Scaler.dylib`TType1PSFont::GetFontInstanceSpec(TType1Transform const&, FixedPoint&, FixedPoint&, FixedPoint&, FixedPoint&, FixedPoint&, FixedRectangle&, FontMetrics&) const + 647
</span><span class='line'>    frame #5: 0x00000001311c6be4 libType1Scaler.dylib`TType1Strike::GetSpecs(StrikeSpecs&) const + 100
</span><span class='line'>    frame #6: 0x00000001311bff2d libType1Scaler.dylib`Type1GetStrikeSpecs(unsigned int, TStrikeDescription const*, StrikeSpecs*) + 48
</span><span class='line'>    frame #7: 0x000000011aba87a0 libFontParser.dylib`TConcreteFontScaler::GetFontInfo(FPFontInfo*) const + 48
</span><span class='line'>    frame #8: 0x000000011ab80525 libFontParser.dylib`TFPFont::FillFontInfo(TFPFontInfo&) const + 203
</span><span class='line'>    frame #9: 0x000000011ab80412 libFontParser.dylib`TFPFont::GetFontInfo() const + 46
</span><span class='line'>    frame #10: 0x000000011ab803de libFontParser.dylib`FPFontIsMonospaced + 9
</span><span class='line'>    frame #11: 0x0000000113bf63cd CoreGraphics`get_font_info + 244
</span><span class='line'>    frame #12: 0x0000000113b84b47 CoreGraphics`get_font_info + 63
</span><span class='line'>    frame #13: 0x0000000113b84af9 CoreGraphics`CGFontGetNumberOfGlyphs + 9
</span><span class='line'>    frame #14: 0x00000001168131ed CoreText`TBaseFont::CopyGraphicsFont() const + 43
</span><span class='line'>    frame #15: 0x0000000116863446 CoreText`TBaseFont::CopyTable(unsigned int) const + 188
</span><span class='line'>    frame #16: 0x00000001168476fc CoreText`TBaseFont::GetCmapTable() const + 60
</span><span class='line'>    frame #17: 0x000000011685d7a2 CoreText`TBaseFont::GetUnicodeEncoding() const + 58
</span><span class='line'>    frame #18: 0x000000011685c367 CoreText`TBaseFont::GetUnicodeCmapSubHeader(void const**) const + 29
</span><span class='line'>    frame #19: 0x000000011685c506 CoreText`TBaseFont::CopyCharacterSet() const + 206
</span><span class='line'>    frame #20: 0x000000011680a2c2 CoreText`TBaseFont::GetCharacterSetInternal() const + 42
</span><span class='line'>    frame #21: 0x0000000116808211 CoreText`CompareCharSet(__CFCharacterSet const*, TBaseFont const*) + 17
</span><span class='line'>    frame #22: 0x000000011680ff1d CoreText`TDescriptorSource::CopyDescriptorsForRequestFromArray(__CFArray const*, __CFDictionary const*, CFComparisonResult (*)(void const*, void const*, void*), void*, unsigned long, bool) const + 1325
</span><span class='line'>    frame #23: 0x000000011680e47e CoreText`TDescriptorSource::CopyDescriptorsForRequest(__CFDictionary const*, __CFSet const*, CFComparisonResult (*)(void const*, void const*, void*), void*, unsigned long, TCFRef&lt;__CFArray const*&gt;*) const + 2374
</span><span class='line'>    frame #24: 0x000000011680d747 CoreText`TDescriptorSource::CopySystemWideFallbackDescriptorForCharacters(TBaseFont const&, unsigned short const*, long, UIFontFlag, TCFRef&lt;__CFArray const*&gt;*) const + 681
</span><span class='line'>    frame #25: 0x000000011680ee03 CoreText`TDescriptorSource::CopySystemWideFallbackDescriptorForString(TBaseFont const&, __CFString const*, CFRange, UIFontFlag, TCFRef&lt;__CFArray const*&gt;*) const + 199
</span><span class='line'>    frame #26: 0x00000001167f9ab3 CoreText`TFontCascade::CreateSystemWideFallback(__CTFont const*, __CFString const*, CFRange) const + 115
</span><span class='line'>    frame #27: 0x00000001167f99ad CoreText`TFontCascade::CreateFallback(__CTFont const*, __CFString const*, CTEmojiPolicy) const + 1525
</span><span class='line'>    frame #28: 0x00000001167c9204 CoreText`TGlyphEncoder::AppendUnmappedCharRun(unsigned int, TCFRef&lt;CTRun*&gt;&, __CTFont const*, CFRange, CFRange, TGlyphList&lt;TDeletedGlyphIndex&gt;&, TGlyphList&lt;TDeletedGlyphIndex&gt;&, TFontCascade const&, TGlyphEncoder::ClusterMatching) + 510
</span><span class='line'>    frame #29: 0x00000001167c8e93 CoreText`TGlyphEncoder::RunUnicodeEncoderRecursively(unsigned int, TCFRef&lt;CTRun*&gt;&&, __CTFont const*, CFRange, TGlyphList&lt;TDeletedGlyphIndex&gt;&, TGlyphList&lt;TDeletedGlyphIndex&gt;&, TFontCascade const*, TGlyphEncoder::ClusterMatching, bool) + 1819
</span><span class='line'>    frame #30: 0x00000001167c8703 CoreText`TGlyphEncoder::RunUnicodeEncoder(TCFRef&lt;CTRun*&gt;&&, __CTFont const*, CFRange, TGlyphList&lt;TDeletedGlyphIndex&gt;&, TFontCascade const*) + 137
</span><span class='line'>    frame #31: 0x00000001167c82e0 CoreText`TGlyphEncoder::EncodeChars(CFRange, TAttributes const&, TGlyphList&lt;TDeletedGlyphIndex&gt;&, TGlyphEncoder::Fallbacks) + 1684
</span><span class='line'>    frame #32: 0x00000001167df8a8 CoreText`TTypesetterAttrString::Initialize(__CFAttributedString const*) + 526
</span><span class='line'>    frame #33: 0x00000001167cbe34 CoreText`CTLineCreateWithAttributedString + 63
</span><span class='line'>    frame #34: 0x000000011cdffe3e UIFoundation`__NSStringDrawingEngine + 9479
</span><span class='line'>    frame #35: 0x000000011cdfd824 UIFoundation`-[NSString(NSExtendedStringDrawing) drawWithRect:options:attributes:context:] + 167
</span><span class='line'>    frame #36: 0x0000000114d69b4b UIKit`-[UILabel _drawTextInRect:baselineCalculationOnly:] + 6596
</span><span class='line'>    frame #37: 0x0000000114d6788a UIKit`-[UILabel drawTextInRect:] + 669
</span><span class='line'>    frame #38: 0x0000000114d69caf UIKit`-[UILabel drawRect:] + 100
</span><span class='line'>    frame #39: 0x0000000114bab3e5 UIKit`-[UIView(CALayerDelegate) drawLayer:inContext:] + 495
</span><span class='line'>    frame #40: 0x00000001148237ea QuartzCore`-[CALayer drawInContext:] + 257
</span><span class='line'>    frame #41: 0x000000011508ab47 UIKit`-[_UILabelContentLayer drawInContext:] + 197
</span><span class='line'>    frame #42: 0x0000000114712faa QuartzCore`CABackingStoreUpdate_ + 2725
</span><span class='line'>    frame #43: 0x00000001148234d4 QuartzCore`___ZN2CA5Layer8display_Ev_block_invoke + 68
</span><span class='line'>    frame #44: 0x000000011482334a QuartzCore`CA::Layer::display_() + 1614
</span><span class='line'>    frame #45: 0x0000000114817e87 QuartzCore`CA::Layer::display_if_needed(CA::Transaction*) + 293
</span><span class='line'>    frame #46: 0x0000000114817f17 QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 35
</span><span class='line'>    frame #47: 0x000000011480c3c9 QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + 277
</span><span class='line'>    frame #48: 0x000000011483a086 QuartzCore`CA::Transaction::commit() + 486
</span><span class='line'>    frame #49: 0x000000011483a7f8 QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 92
</span><span class='line'>    frame #50: 0x0000000118485c37 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23
</span><span class='line'>    frame #51: 0x0000000118485ba7 CoreFoundation`__CFRunLoopDoObservers + 391
</span><span class='line'>    frame #52: 0x000000011847b7fb CoreFoundation`__CFRunLoopRun + 1147
</span><span class='line'>    frame #53: 0x000000011847b0f8 CoreFoundation`CFRunLoopRunSpecific + 488
</span><span class='line'>    frame #54: 0x0000000119682ad2 GraphicsServices`GSEventRunModal + 161
</span><span class='line'>    frame #55: 0x0000000114af0f09 UIKit`UIApplicationMain + 171
</span></code></pre></td></tr></table></div></figure>


<p>大致可以看到， 是UILabel在 <strong>drawTextInRect</strong>时，获取某些字元信息时出异常了。
我们的目的就是想看一下到底是什么文字引起这个问题的。</p>

<p>我们都知道 text 是存放在 UILabel.text 的属性上，第一印象都认为  <code>po self.text</code> 就可以看到罪魁祸首了。</p>

<p>OK， 我们看一下实际输出结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) po self.text
</span><span class='line'>error: use of undeclared identifier 'self'
</span><span class='line'>error: 1 errors parsing expression</span></code></pre></td></tr></table></div></figure>


<p>可以看到提示，没有找到 self ，因为当前栈帧已经去到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>frame #0: 0x0000000118914c6b libc++abi.dylib`__cxa_throw
</span><span class='line'>frame #1: 0x00000001311c782f libType1Scaler.dylib`TType1LWFNMultipleMasterHFMXTable::TType1LWFNMultipleMasterHFMXTable(TFontObjectSurrogate const&, int, short, short, int*) + 121
</span><span class='line'> 
</span><span class='line'> ``` 
</span><span class='line'> 所以提示没找到self也是很正常， 那么我们切换一下当前堆栈，把它切换到 ``` [UILabel drawRect:] ``` 这个函数里面:
</span><span class='line'> 
</span><span class='line'> ```
</span><span class='line'> UIKit`-[UILabel drawRect:]:
</span><span class='line'>0x114d69c4b &lt;+0&gt;:   pushq  %rbp
</span><span class='line'>0x114d69c4c &lt;+1&gt;:   movq   %rsp, %rbp
</span><span class='line'>0x114d69c4f &lt;+4&gt;:   pushq  %rbx
</span><span class='line'>0x114d69c50 &lt;+5&gt;:   subq   $0x48, %rsp
</span><span class='line'>0x114d69c54 &lt;+9&gt;:   movq   %rdi, %rbx
</span><span class='line'>0x114d69c57 &lt;+12&gt;:  testq  %rbx, %rbx
</span><span class='line'>0x114d69c5a &lt;+15&gt;:  je     0x114d69c71               ; &lt;+38&gt;
</span><span class='line'>0x114d69c5c &lt;+17&gt;:  movq   0xa6c4ad(%rip), %rdx      ; "bounds"
</span><span class='line'>0x114d69c63 &lt;+24&gt;:  leaq   -0x30(%rbp), %rdi
</span><span class='line'>0x114d69c67 &lt;+28&gt;:  movq   %rbx, %rsi
</span><span class='line'>0x114d69c6a &lt;+31&gt;:  callq  0x1155c2af6               ; symbol stub for: objc_msgSend_stret
</span><span class='line'>0x114d69c6f &lt;+36&gt;:  jmp    0x114d69c7c               ; &lt;+49&gt;
</span><span class='line'>0x114d69c71 &lt;+38&gt;:  xorps  %xmm0, %xmm0
</span><span class='line'>0x114d69c74 &lt;+41&gt;:  movaps %xmm0, -0x20(%rbp)
</span><span class='line'>0x114d69c78 &lt;+45&gt;:  movaps %xmm0, -0x30(%rbp)
</span><span class='line'>0x114d69c7c &lt;+49&gt;:  movq   0xa7cdd5(%rip), %rsi      ; "drawTextInRect:"
</span><span class='line'>0x114d69c83 &lt;+56&gt;:  movq   -0x18(%rbp), %rax
</span><span class='line'>0x114d69c87 &lt;+60&gt;:  movq   %rax, 0x18(%rsp)
</span><span class='line'>0x114d69c8c &lt;+65&gt;:  movq   -0x20(%rbp), %rax
</span><span class='line'>0x114d69c90 &lt;+69&gt;:  movq   %rax, 0x10(%rsp)
</span><span class='line'>0x114d69c95 &lt;+74&gt;:  movq   -0x30(%rbp), %rax
</span><span class='line'>0x114d69c99 &lt;+78&gt;:  movq   -0x28(%rbp), %rcx
</span><span class='line'>0x114d69c9d &lt;+82&gt;:  movq   %rcx, 0x8(%rsp)
</span><span class='line'>0x114d69ca2 &lt;+87&gt;:  movq   %rax, (%rsp)
</span><span class='line'>0x114d69ca6 &lt;+91&gt;:  movq   %rbx, %rdi
</span><span class='line'>0x114d69ca9 &lt;+94&gt;:  callq  *0xaf0531(%rip)           ; (void *)0x0000000117c64800: objc_msgSend
</span><span class='line'>0x114d69caf &lt;+100&gt;: addq   $0x48, %rsp
</span><span class='line'>0x114d69cb3 &lt;+104&gt;: popq   %rbx
</span><span class='line'>0x114d69cb4 &lt;+105&gt;: popq   %rbp
</span><span class='line'>0x114d69cb5 &lt;+106&gt;: retq   </span></code></pre></td></tr></table></div></figure>


<p>再看看结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) po self.text
</span><span class='line'>error: use of undeclared identifier 'self'
</span><span class='line'>error: 1 errors parsing expression
</span></code></pre></td></tr></table></div></figure>


<p>同样，也是没有找到self标识符。但是我们从上面的汇编代码可以看到，在调用 drawTextInRext 的时候，实际上最后也是调用 <code>objc_msgSend</code> 这个函数。</p>

<p>然后我们再看一下 <code>objc_msgSend</code> 的函数原型：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)
</span></code></pre></td></tr></table></div></figure>


<p>可以清楚的看到，传给objc_msgSend的第一个参数就是 self 对象。</p>

<p>而且从</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0x114d69c7c &lt;+49&gt;:  movq   0xa7cdd5(%rip), %rsi      ; "drawTextInRect:"
</span><span class='line'>0x114d69c83 &lt;+56&gt;:  movq   -0x18(%rbp), %rax
</span><span class='line'>0x114d69c87 &lt;+60&gt;:  movq   %rax, 0x18(%rsp)
</span><span class='line'>0x114d69c8c &lt;+65&gt;:  movq   -0x20(%rbp), %rax
</span><span class='line'>0x114d69c90 &lt;+69&gt;:  movq   %rax, 0x10(%rsp)
</span><span class='line'>0x114d69c95 &lt;+74&gt;:  movq   -0x30(%rbp), %rax
</span><span class='line'>0x114d69c99 &lt;+78&gt;:  movq   -0x28(%rbp), %rcx
</span><span class='line'>0x114d69c9d &lt;+82&gt;:  movq   %rcx, 0x8(%rsp)
</span><span class='line'>0x114d69ca2 &lt;+87&gt;:  movq   %rax, (%rsp)
</span><span class='line'>0x114d69ca6 &lt;+91&gt;:  movq   %rbx, %rdi
</span><span class='line'>0x114d69ca9 &lt;+94&gt;:  callq  *0xaf0531(%rip)           ; (void *)0x0000000117c64800: objc_msgSend
</span></code></pre></td></tr></table></div></figure>


<p>这里可以看到， 在 drawRect 里面，实际上是调用了 <code>drawTextInRect</code>,根据一些调用约定，可以判断 <code>objc_msgSend</code> 的第一个参数是最后压栈的，这时候我们可以猜测就是 <strong>rbx</strong>的寄存器的值。</p>

<p>我们可以通过 <strong>register read</strong> 指令查看当前寄存器的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) register read
</span><span class='line'>General Purpose Registers:
</span><span class='line'>       rbx = 0x00007f9f833d71e0
</span><span class='line'>       rbp = 0x00007fff5096bf70
</span><span class='line'>       rsp = 0x00007fff5096bf20
</span><span class='line'>       r12 = 0x00007f9f83102850
</span><span class='line'>       r13 = 0x00007f9f833d71e0
</span><span class='line'>       r14 = 0x0000000000000020
</span><span class='line'>       r15 = 0x00007f9f80f119f0
</span><span class='line'>       rip = 0x0000000114d69caf  UIKit`-[UILabel drawRect:] + 100
</span><span class='line'>13 registers were unavailable.
</span></code></pre></td></tr></table></div></figure>


<p>然后我们尝试一下输出 rbx 的对象类型（如果它是一个对象的话）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) po [(id)$rbx class]
</span><span class='line'>UILabel
</span></code></pre></td></tr></table></div></figure>


<p>可以看到rbx就是我们要找的那个UILabel对象，既然找到UILabel，那么就很容易找到相应的 text 了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) po [(id)$rbx text]
</span><span class='line'>ᘡ ‍Amy🌀晴天冠 ୨୧˙˳⋆﻿
</span></code></pre></td></tr></table></div></figure>


<p>可以看到 <strong> ᘡ ‍Amy🌀晴天冠 ୨୧˙˳⋆﻿ </strong> 是这个文本引起异常。</p>

<p>如果不好判断哪些寄存器是存放 self 对象的话，可以一个一个打印一下类型试试。</p>

<h3>总结</h3>

<ul>
<li>很多时候异常了，而且不在我们的函数里面，这个时候直接取 self 是取不到的。</li>
<li>所有方法最终都调用了<code>objc_msgSend</code>， 调用的对象会作为第一个参数（self）传给它。</li>
<li>可以通过查看寄存器命令 <code>register read</code>， 获取到self地址。</li>
<li>也可以通过<code>frame</code> 指令查看当前栈的参数信息。 具体可以看看 <code>help frame</code> 的输出信息。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dealloc 时取 Weak Self 时崩溃]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/05/10/store-weak-crash-in-dealloc/"/>
    <updated>2016-05-10T15:15:20+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/05/10/store-weak-crash-in-dealloc</id>
    <content type="html"><![CDATA[<p>今天无意这中遇到一个奇怪的崩溃，先上引起崩溃的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    __weak __typeof(self)weak_self = self;
</span><span class='line'>    NSLog(@"%@", weak_self);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>当执行到dealloc的时候，程序就crash 掉了。</p>

<!--MORE-->


<p> 崩溃信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>objc[4572]: Cannot form weak reference to instance (0x160f6f890) of class MFChatRoomBoardController. It is possible that this object was over-released, or is in the process of deallocation.
</span><span class='line'>(lldb) 
</span><span class='line'>error: empty command
</span><span class='line'>(lldb) bt
</span><span class='line'>* thread #1: tid = 0x35914d, 0x0000000182307aac libobjc.A.dylib`_objc_trap(), queue = 'com.apple.main-thread', stop reason = EXC_BREAKPOINT (code=1, subcode=0x182307aac)
</span><span class='line'>  * frame #0: 0x0000000182307aac libobjc.A.dylib`_objc_trap()
</span><span class='line'>    frame #1: 0x0000000182307b24 libobjc.A.dylib`_objc_fatal(char const*, ...) + 88
</span><span class='line'>    frame #2: 0x0000000182319890 libobjc.A.dylib`weak_register_no_lock + 316
</span><span class='line'>    frame #3: 0x0000000182320688 libobjc.A.dylib`objc_initWeak + 224
</span><span class='line'>    frame #4: 0x000000010022bf8c MakeFriends`-[MFChatRoomBoardController dealloc](self=0x0000000160f6f890, _cmd="dealloc") + 36 at MFChatRoomBoardController.m:31
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>其中，可以在控制台明确看到这样一段描述:</p>

<blockquote><p>objc[4572]: Cannot form weak reference to instance (0x160f6f890) of class MFChatRoomBoardController. It is possible that this object was over-released, or is in the process of deallocation.</p></blockquote>

<p>说明不允许在 dealloc 的时候取 weak self.</p>

<p>查看了一下 <code>weak_register_no_lock</code> 的函数代码，找到问题所在。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id 
</span><span class='line'>weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)
</span><span class='line'>{
</span><span class='line'>    objc_object *referent = (objc_object *)referent_id;
</span><span class='line'>    objc_object **referrer = (objc_object **)referrer_id;
</span><span class='line'>
</span><span class='line'>    if (!referent  ||  referent-&gt;isTaggedPointer()) return referent_id;
</span><span class='line'>
</span><span class='line'>    // ensure that the referenced object is viable
</span><span class='line'>    bool deallocating;
</span><span class='line'>    if (!referent-&gt;ISA()-&gt;hasCustomRR()) {
</span><span class='line'>        deallocating = referent-&gt;rootIsDeallocating();
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        BOOL (*allowsWeakReference)(objc_object *, SEL) = 
</span><span class='line'>            (BOOL(*)(objc_object *, SEL))
</span><span class='line'>            object_getMethodImplementation((id)referent, 
</span><span class='line'>                                           SEL_allowsWeakReference);
</span><span class='line'>        if ((IMP)allowsWeakReference == _objc_msgForward) {
</span><span class='line'>            return nil;
</span><span class='line'>        }
</span><span class='line'>        deallocating =
</span><span class='line'>            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (deallocating) {
</span><span class='line'>        _objc_fatal("Cannot form weak reference to instance (%p) of "
</span><span class='line'>                    "class %s. It is possible that this object was "
</span><span class='line'>                    "over-released, or is in the process of deallocation.",
</span><span class='line'>                    (void*)referent, object_getClassName((id)referent));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // now remember it and where it is being stored
</span><span class='line'>    weak_entry_t *entry;
</span><span class='line'>    if ((entry = weak_entry_for_referent(weak_table, referent))) {
</span><span class='line'>        append_referrer(entry, referrer);
</span><span class='line'>    } 
</span><span class='line'>    else {
</span><span class='line'>        weak_entry_t new_entry;
</span><span class='line'>        new_entry.referent = referent;
</span><span class='line'>        new_entry.out_of_line = 0;
</span><span class='line'>        new_entry.inline_referrers[0] = referrer;
</span><span class='line'>        for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) {
</span><span class='line'>            new_entry.inline_referrers[i] = nil;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        weak_grow_maybe(weak_table);
</span><span class='line'>        weak_entry_insert(weak_table, &new_entry);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Do not set *referrer. objc_storeWeak() requires that the 
</span><span class='line'>    // value not change.
</span><span class='line'>
</span><span class='line'>    return referent_id;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，runtime 是通过检查引用计数的个数来判断对象是否在 deallocting， 然后通过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (deallocating) {
</span><span class='line'>    _objc_fatal("Cannot form weak reference to instance (%p) of "
</span><span class='line'>                "class %s. It is possible that this object was "
</span><span class='line'>                "over-released, or is in the process of deallocation.",
</span><span class='line'>                (void*)referent, object_getClassName((id)referent));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这段代码让程序crash。</p>

<p>再看一下 _objc_fatal 这个函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void _objc_fatal(const char *fmt, ...)
</span><span class='line'>{
</span><span class='line'>    va_list ap; 
</span><span class='line'>    char *buf1;
</span><span class='line'>    char *buf2;
</span><span class='line'>
</span><span class='line'>    va_start(ap,fmt); 
</span><span class='line'>    vasprintf(&buf1, fmt, ap);
</span><span class='line'>    va_end (ap);
</span><span class='line'>
</span><span class='line'>    asprintf(&buf2, "objc[%d]: %s\n", getpid(), buf1);
</span><span class='line'>    _objc_syslog(buf2);
</span><span class='line'>    _objc_crashlog(buf2);
</span><span class='line'>
</span><span class='line'>    _objc_trap();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到这个函数实际会在控制台输出一段信息，然后调用 _bojc_trap() 引起 crash. 而最后一个函数调用刚好也对上我们之前的崩溃堆栈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[_delegateScrollViewAnimationEnded Crash处理]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/03/30/uiscrollview-delegatescrollviewanimationended-crash/"/>
    <updated>2016-03-30T00:57:31+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/03/30/uiscrollview-delegatescrollviewanimationended-crash</id>
    <content type="html"><![CDATA[<p>在项目开发过程中，多次遇到UIScrollView滑动时引起的崩溃，在这里分析一下，mark 下处理过程。</p>

<p>先看一下崩溃堆栈：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) bt all
</span><span class='line'>* thread #1: tid = 0x4bb501, 0x00000001058451a8 CoreFoundation`___forwarding___ + 776, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS  (code=EXC_I386_GPFLT)
</span><span class='line'>    frame #0: 0x00000001058451a8 CoreFoundation`___forwarding___ + 776
</span><span class='line'>    frame #1: 0x0000000105844e18 CoreFoundation`__forwarding_prep_0___ + 120
</span><span class='line'>  * frame #2: 0x0000000105d6884d UIKit`-[UIScrollView(UIScrollViewInternal) _delegateScrollViewAnimationEnded] + 46
</span><span class='line'>    frame #3: 0x0000000105d6894f UIKit`-[UIScrollView(UIScrollViewInternal) _scrollViewAnimationEnded:finished:] + 181
</span><span class='line'>    frame #4: 0x0000000105dddab7 UIKit`-[UIAnimator stopAnimation:] + 395
</span><span class='line'>    frame #5: 0x0000000105dde0bf UIKit`-[UIAnimator(Static) _advanceAnimationsOfType:withTimestamp:] + 234
</span><span class='line'>    frame #6: 0x00000001095a5747 QuartzCore`CA::Display::DisplayLinkItem::dispatch() + 37
</span><span class='line'>    frame #7: 0x00000001095a560f QuartzCore`CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long) + 315
</span><span class='line'>    frame #8: 0x000000010584df64 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 20
</span><span class='line'>    frame #9: 0x000000010584db25 CoreFoundation`__CFRunLoopDoTimer + 1045
</span><span class='line'>    frame #10: 0x0000000105810e5d CoreFoundation`__CFRunLoopRun + 1901
</span><span class='line'>    frame #11: 0x0000000105810486 CoreFoundation`CFRunLoopRunSpecific + 470
</span><span class='line'>    frame #12: 0x0000000108e799f0 GraphicsServices`GSEventRunModal + 161
</span><span class='line'>    frame #13: 0x0000000105cd1420 UIKit`UIApplicationMain + 1282
</span><span class='line'>    frame #14: 0x000000010504f32f UIScrollViewDelegate`main(argc=1, argv=0x00007fff5abb0360) + 111 at main.m:14
</span><span class='line'>    frame #15: 0x0000000107e5e145 libdyld.dylib`start + 1
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<!--MORE-->


<p>从崩溃信息里面，我们可以看到 <strong> stop reason = EXC_BAD_ACCESS </strong>， 非法地址访问（野指针）。从堆栈 <strong>[UIAnimator stopAnimation:] -> [UIScrollView(UIScrollViewInternal) _scrollViewAnimationEnded:finished:] </strong> 可以看出是动画完成后，调用scrollview的方法引起的非法访问。经过实验验证，是scrollview.delegate 引起的。 <strong>也就是说，scrollview在做动画的过程中，scrollview.delegate 被释放了。</strong>*</p>

<p>简单写了一些测试代码重现了这个崩溃</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ScrollViewController
</span><span class='line'>
</span><span class='line'>- (IBAction)onBackClick:(id)sender
</span><span class='line'>{
</span><span class='line'>    [self.scrollview setContentOffset:CGPointMake(0, self.scrollview.bounds.size.height * 3) animated:YES];
</span><span class='line'>    [self.navigationController popViewControllerAnimated:NO];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在iOS7 和 iOS8 的系统下，一点返回按钮，pop 出当前页面，就会马上崩溃。</li>
<li>在iOS9下没有问题（由于属性修饰符改成weak）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//iOS9 以前
</span><span class='line'>@property(nonatomic,unsafe_unretain) id&lt;UIScrollViewDelegate&gt; delegate; 
</span><span class='line'>
</span><span class='line'>//iOS9
</span><span class='line'>@property(nullable,nonatomic,weak) id&lt;UIScrollViewDelegate&gt; delegate; 
</span></code></pre></td></tr></table></div></figure>


<h3>解决方法：</h3>

<p>崩溃的原因已经很明确，只要可以保证UIScrollView 的 delegate对象在释放的时候，把<code>scrollview.dlegate = nil;</code> 就可以解决问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ScrollViewController
</span><span class='line'>- (void)dealloc {
</span><span class='line'>  self.scrollview.delegate = nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>主动设置 scrollview.delegate = nil; 可以很好的解决崩溃。但是稍不注意，项目组的其他开发同事又很容易忘记，或者一不小心，又引起崩溃了。有没有办法可以一劳永逸呢？</p>

<h3>更好的解决方法：</h3>

<p>主要思路：通过Runtime，修改 dealloc 方法，让代理对象在释放时自动把scrollview.delegate置空。</p>

<ol>
<li><p>首先，通过 <strong>method swizzling</strong> 给NSObject添加 deallocBlock <a href="https://github.com/kaihaodir/BSUiKit/blob/master/NSObject%2BDealloc.m">查看完成代码</a></p>

<pre><code class="`"> typedef void (^DeallocCallback)();

 @interface NSObject(Deallocing)

 + (void)hookNSObjectDealloc;

 - (void)setDeallocCallback:(DeallocCallback)callback;

 - (DeallocCallback)deallocCallback;

 @end



 @implementation NSObject(Deallocing)
 - (void)myselfDealloc {
     DeallocCallback callback = [self deallocCallback];
     if (callback) {
         callback(); //对象释放前的主要操作
     }

 [self originalDealloc];
 }
 @end
</code></pre></li>
<li><p>通过<strong>method swizzling</strong> 修改UIScrollView 的 <strong>setDelegate</strong> 方法</p>

<pre><code class="`"> - (void)myselfSetDelegate:(NSObject *)delegate
 {
     if (delegate) {
         UIScrollView * __weak weak_self = (UIScrollView *)self;
         [delegate setDeallocCallback:^{
             weak_self.delegate = nil;
         }];
     }
     //调用原来方法
     [self originalSetDelegate:delegate];
 }   
</code></pre></li>
<li><p>在App初始化的时候，调用一下 ScrollView 的 swizzling 方法，就可以解决这类型的崩溃（包括：UITableView, UIWebView, UICollectionView 动画时delegate被释放引起的崩溃）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSTimer 使用注意事项]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/03/21/nstimer-retain-target/"/>
    <updated>2016-03-21T23:13:50+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/03/21/nstimer-retain-target</id>
    <content type="html"><![CDATA[<p>NSTimer是ios上比较常用的定时器组件，在使用了一段时间后，发现有些地方是需要注意一下的。</p>

<ol>
<li><p>NSTimer 是需要配合NSRunLoop 才可以正常工作的。</p>

<pre><code class="` "> + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                              invocation:(NSInvocation *)invocation
                                 repeats:(BOOL)repeats

 + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti 
                                       target:(id)aTarget 
                                     selector:(SEL)aSelector 
                                     userInfo:(nullable id)userInfo 
                                     repeats:(BOOL)yesOrNo;
</code></pre>

<p> 使用这个类方法，会自动添加到当前的RunLoop里面。关于RunLoop的介绍网上有很多资料，推荐看看 <a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>。
 <!--MORE--></p></li>
<li><p>当RunLoop处于UITrackingRunLoopMode模式的时候（滑动UIScrollView的时候），使用</p>

<pre><code>scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                    invocation:(NSInvocation *)invocation
                       repeats:(BOOL)repeats
</code></pre>

<p>的类方法创建的Timer，是不会收到响应事件。只有RunLoop切换到Default模式时才可以正常响应。如果希望滑动时也可以响应Timer时间，需要把Timer加到RunLoop并指定模式为<strong>NSRunLoopCommonModes</strong></p>

<pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(test) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre></li>
<li><p>NSTimer 会强引用 target 对象，很容易造成内存泄露或者其它因生命周期和预期不一至导致的问题。</p>

<p> 我们先看一段常见的事例代码</p>

<pre><code class="`"> @implementation TViewController
 {
     NSTimer *_timer;
 }

 - (void)dealloc
 {
     NSLog(@"%s", __func__);
 }

 - (void)viewDidLoad
 {
     [super viewDidLoad];
     _timer = [NSTimer scheduledTimerWithTimeInterval:1
                                               target:self 
                                             selector:@selector(onTimeout) 
                                             userInfo:nil 
                                              repeats:YES];
 }

 - (void)onTimeout
 {
     NSLog(@"%s", __func__);
 }

 @end
</code></pre>

<p> 大家可能会觉得，当这个ViewController被 pop 掉后会正常释放，timer 也会停掉。但实际的情况不是你想的那样。以下log是Push这个ViewController后，然后点击返回的过程。</p>

<p> 2016-03-24 00:42:19.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:20.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:21.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:22.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 <strong>2016-03-24 00:42:23.369 NSTimerDemo[14916:3982566] -[TViewController viewDidDisappear:]</strong>
 2016-03-24 00:42:23.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:24.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:25.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]</p>

<p> 从日志上来看，dealloc方法确实没有执行，而且timer事件还一直在触发。</p>

<p> OK,既然Timer强引用了ViewController，那把ViewController改成<strong>__weak</strong>不就是可以解决问题了？
 于是我们把创建Timer的代码改成</p>

<pre><code class="`"> __weak typeof(self) weak_self = self;
 _timer = [NSTimer scheduledTimerWithTimeInterval:1
                                           target:weak_self
                                         selector:@selector(onTimeout)
                                         userInfo:nil
                                          repeats:YES];
</code></pre>

<p> 发现输出的log和之前的一样，难道weak对象根本没起作用？
 用Instrement查看了一下内存情况，发现真的是Timer强引用Target对象</p>

<p> <img src="http://7xryar.com1.z0.glb.clouddn.com/NSTimer-Retain-Target.png" alt="Timer Retain Target" /></p>

<p> 目前主要是处于一个闭环（环形引用）的状态，我们要想办法打破这种状态，而且<strong>__weak</strong>设置给Timer也不会破坏Timer强引用Target。</p>

<p> 于是，我们引用一个包装对象，让Timer强引用这个包装对象，包装对象弱引用Target(ViewController)
 ViewController &mdash;> Timer &mdash;>Wrapper &hellip;>ViewController 这样就可以破坏环形引用。</p>

<pre><code class="`"> @Interface Wrapper
 @property (weak, nonatom) id target;
 @end
</code></pre>

<p> 那么创建Timer的类方法的Target对象不是传<code>self</code>, 而是传 wrapper 对象。
 另外，wrapper对象还要把Timer的事件传递到真正的target上。</p>

<p> 详细的 Timer Wrapper 可以看完代码 <a href="https://github.com/kaihaodir/BSUiKit/blob/master/BSTimer.h">BSTimer</a></p>

<p> 最后其实可以用dispatch_time解决强引用问题，但是dispatch_time在暂停功能上处理起来比较麻烦。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arc下NSException有可能会内存泄露]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/03/13/arc-nsexception-cause-memory-leak/"/>
    <updated>2016-03-13T17:00:52+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/03/13/arc-nsexception-cause-memory-leak</id>
    <content type="html"><![CDATA[<p>在使用Instrumnents对程序进行内存测试的时候，发现有几处异常处理的地方提示内存泄露。经过分析得知，<strong>因为异常处理，改变代码执行路径，导致编译生成的 release 代码没有执行</strong>。</p>

<!--more-->


<p>简单写了些测试代码验证：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad {
</span><span class='line'>    
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    
</span><span class='line'>    @try {
</span><span class='line'>        NSMutableArray *stringList = [[NSMutableArray alloc] init];
</span><span class='line'>        for (int i = 0; i &lt; 100; i++) {
</span><span class='line'>            [stringList addObject: @"string instance."];
</span><span class='line'>        }
</span><span class='line'>        [self throwException];
</span><span class='line'>    }
</span><span class='line'>    @catch (NSException *exception) {
</span><span class='line'>        NSLog(@"catch Exception : %@", exception);
</span><span class='line'>    }
</span><span class='line'>    @finally {
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)throwException
</span><span class='line'>{
</span><span class='line'>    [NSException raise:@"An Exception." format:@"Exception Description."];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>反复进出这个页面几次后，在Instruments上果然看到提示内存泄露，而且泄露的地方就指明是 <code>@try{ }</code> 里面创建的对象。</p>

<p><img src="http://7xryar.com1.z0.glb.clouddn.com/exception-memory-leak.png" alt="img" /></p>

<h4>解决思路</h4>

<p>1, 尽量不要在@try{}里面有操作，导致对象的引用引用计数增加。<code>@try{ }</code> 语句块里面只有有可能抛出异常的语句。</p>

<p><strong>修改后的代码:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad {
</span><span class='line'>    
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *stringList = [[NSMutableArray alloc] init];
</span><span class='line'>    for (int i = 0; i &lt; 100; i++) {
</span><span class='line'>        [stringList addObject: @"string instance."];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    @try {
</span><span class='line'>        [self throwException];
</span><span class='line'>    }
</span><span class='line'>    @catch (NSException *exception) {
</span><span class='line'>        NSLog(@"catch Exception : %@", exception);
</span><span class='line'>    }
</span><span class='line'>    @finally {
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>最后用Instruments检查一下，一切正常了。</p>

<p>2, 查看了苹果的开发文档，发现有这么一段描述:</p>

<blockquote><pre><code>By default in Objective C, ARC is not exception-safe for normal releases:
It does not end the lifetime of __strong variables when their scopes are abnormally terminated by an exception.
It does not perform releases which would occur at the end of a full-expression if that full-expression throws an exception.
A program may be compiled with the option -fobjc-arc-exceptions in order to enable these, or with the option -fno-objc-arc-exceptions to explicitly disable them, with the last such argument “winning”.
</code></pre></blockquote>
]]></content>
  </entry>
  
</feed>
