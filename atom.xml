<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Thinking...]]></title>
  <link href="http://kaihaodir.github.io/atom.xml" rel="self"/>
  <link href="http://kaihaodir.github.io/"/>
  <updated>2016-03-30T02:17:35+08:00</updated>
  <id>http://kaihaodir.github.io/</id>
  <author>
    <name><![CDATA[Kai]]></name>
    <email><![CDATA[kaihaodir@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[_delegateScrollViewAnimationEnded Crash处理]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/03/30/uiscrollview-delegatescrollviewanimationended-crash/"/>
    <updated>2016-03-30T00:57:31+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/03/30/uiscrollview-delegatescrollviewanimationended-crash</id>
    <content type="html"><![CDATA[<p>在项目开发过程中，多次遇到UIScrollView滑动时引起的崩溃，在这里分析一下，mark 下处理过程。</p>

<p>先看一下崩溃堆栈：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) bt all
</span><span class='line'>* thread #1: tid = 0x4bb501, 0x00000001058451a8 CoreFoundation`___forwarding___ + 776, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS  (code=EXC_I386_GPFLT)
</span><span class='line'>    frame #0: 0x00000001058451a8 CoreFoundation`___forwarding___ + 776
</span><span class='line'>    frame #1: 0x0000000105844e18 CoreFoundation`__forwarding_prep_0___ + 120
</span><span class='line'>  * frame #2: 0x0000000105d6884d UIKit`-[UIScrollView(UIScrollViewInternal) _delegateScrollViewAnimationEnded] + 46
</span><span class='line'>    frame #3: 0x0000000105d6894f UIKit`-[UIScrollView(UIScrollViewInternal) _scrollViewAnimationEnded:finished:] + 181
</span><span class='line'>    frame #4: 0x0000000105dddab7 UIKit`-[UIAnimator stopAnimation:] + 395
</span><span class='line'>    frame #5: 0x0000000105dde0bf UIKit`-[UIAnimator(Static) _advanceAnimationsOfType:withTimestamp:] + 234
</span><span class='line'>    frame #6: 0x00000001095a5747 QuartzCore`CA::Display::DisplayLinkItem::dispatch() + 37
</span><span class='line'>    frame #7: 0x00000001095a560f QuartzCore`CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long) + 315
</span><span class='line'>    frame #8: 0x000000010584df64 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 20
</span><span class='line'>    frame #9: 0x000000010584db25 CoreFoundation`__CFRunLoopDoTimer + 1045
</span><span class='line'>    frame #10: 0x0000000105810e5d CoreFoundation`__CFRunLoopRun + 1901
</span><span class='line'>    frame #11: 0x0000000105810486 CoreFoundation`CFRunLoopRunSpecific + 470
</span><span class='line'>    frame #12: 0x0000000108e799f0 GraphicsServices`GSEventRunModal + 161
</span><span class='line'>    frame #13: 0x0000000105cd1420 UIKit`UIApplicationMain + 1282
</span><span class='line'>    frame #14: 0x000000010504f32f UIScrollViewDelegate`main(argc=1, argv=0x00007fff5abb0360) + 111 at main.m:14
</span><span class='line'>    frame #15: 0x0000000107e5e145 libdyld.dylib`start + 1
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<!--MORE-->


<p>从崩溃信息里面，我们可以看到 <strong> stop reason = EXC_BAD_ACCESS </strong>， 非法地址访问（野指针）。从堆栈 <strong>[UIAnimator stopAnimation:] -> [UIScrollView(UIScrollViewInternal) _scrollViewAnimationEnded:finished:] </strong> 可以看出是动画完成后，调用scrollview的方法引起的非法访问。经过实验验证，是scrollview.delegate 引起的。 <strong>也就是说，scrollview在做动画的过程中，scrollview.delegate 被释放了。</strong>*</p>

<p>简单写了一些测试代码重现了这个崩溃</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ScrollViewController
</span><span class='line'>
</span><span class='line'>- (IBAction)onBackClick:(id)sender
</span><span class='line'>{
</span><span class='line'>    [self.scrollview setContentOffset:CGPointMake(0, self.scrollview.bounds.size.height * 3) animated:YES];
</span><span class='line'>    [self.navigationController popViewControllerAnimated:NO];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在iOS7 和 iOS8 的系统下，一点返回按钮，pop 出当前页面，就会马上崩溃。</li>
<li>在iOS9下没有问题（由于属性修饰符改成weak）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//iOS9 以前
</span><span class='line'>@property(nonatomic,unsafe_unretain) id&lt;UIScrollViewDelegate&gt; delegate; 
</span><span class='line'>
</span><span class='line'>//iOS9
</span><span class='line'>@property(nullable,nonatomic,weak) id&lt;UIScrollViewDelegate&gt; delegate; 
</span></code></pre></td></tr></table></div></figure>


<h3>解决方法：</h3>

<p>崩溃的原因已经很明确，只要可以保证UIScrollView 的 delegate对象在释放的时候，把<code>scrollview.dlegate = nil;</code> 就可以解决问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation ScrollViewController
</span><span class='line'>- (void)dealloc {
</span><span class='line'>  self.scrollview.delegate = nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>主动设置 scrollview.delegate = nil; 可以很好的解决崩溃。但是稍不注意，项目组的其他开发同事又很容易忘记，或者一不小心，又引起崩溃了。有没有办法可以一劳永逸呢？</p>

<h3>更好的解决方法：</h3>

<p>主要思路：通过Runtime，修改 dealloc 方法，让代理对象在释放时自动把scrollview.delegate置空。</p>

<ol>
<li><p>首先，通过 <strong>method swizzling</strong> 给NSObject添加 deallocBlock <a href="https://github.com/kaihaodir/BSUiKit/blob/master/NSObject%2BDealloc.m">查看完成代码</a></p>

<pre><code class="`"> typedef void (^DeallocCallback)();

 @interface NSObject(Deallocing)

 + (void)hookNSObjectDealloc;

 - (void)setDeallocCallback:(DeallocCallback)callback;

 - (DeallocCallback)deallocCallback;

 @end



 @implementation NSObject(Deallocing)
 - (void)myselfDealloc {
     DeallocCallback callback = [self deallocCallback];
     if (callback) {
         callback(); //对象释放前的主要操作
     }

 [self originalDealloc];
 }
 @end
</code></pre></li>
<li><p>通过<strong>method swizzling</strong> 修改UIScrollView 的 <strong>setDelegate</strong> 方法</p>

<pre><code class="`"> - (void)myselfSetDelegate:(NSObject *)delegate
 {
     if (delegate) {
         UIScrollView * __weak weak_self = (UIScrollView *)self;
         [delegate setDeallocCallback:^{
             weak_self.delegate = nil;
         }];
     }
     //调用原来方法
     [self originalSetDelegate:delegate];
 }   
</code></pre></li>
<li><p>在App初始化的时候，调用一下 ScrollView 的 swizzling 方法，就可以解决这类型的崩溃（包括：UITableView, UIWebView, UICollectionView 动画时delegate被释放引起的崩溃）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSTimer 使用注意事项]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/03/21/nstimer-retain-target/"/>
    <updated>2016-03-21T23:13:50+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/03/21/nstimer-retain-target</id>
    <content type="html"><![CDATA[<p>NSTimer是ios上比较常用的定时器组件，在使用了一段时间后，发现有些地方是需要注意一下的。</p>

<ol>
<li><p>NSTimer 是需要配合NSRunLoop 才可以正常工作的。</p>

<pre><code class="` "> + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                              invocation:(NSInvocation *)invocation
                                 repeats:(BOOL)repeats

 + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti 
                                       target:(id)aTarget 
                                     selector:(SEL)aSelector 
                                     userInfo:(nullable id)userInfo 
                                     repeats:(BOOL)yesOrNo;
</code></pre>

<p> 使用这个类方法，会自动添加到当前的RunLoop里面。关于RunLoop的介绍网上有很多资料，推荐看看 <a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>。
 <!--MORE--></p></li>
<li><p>当RunLoop处于UITrackingRunLoopMode模式的时候（滑动UIScrollView的时候），使用</p>

<pre><code>scheduledTimerWithTimeInterval:(NSTimeInterval)seconds
                    invocation:(NSInvocation *)invocation
                       repeats:(BOOL)repeats
</code></pre>

<p>的类方法创建的Timer，是不会收到响应事件。只有RunLoop切换到Default模式时才可以正常响应。如果希望滑动时也可以响应Timer时间，需要把Timer加到RunLoop并指定模式为<strong>NSRunLoopCommonModes</strong></p>

<pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(test) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre></li>
<li><p>NSTimer 会强引用 target 对象，很容易造成内存泄露或者其它因生命周期和预期不一至导致的问题。</p>

<p> 我们先看一段常见的事例代码</p>

<pre><code class="`"> @implementation TViewController
 {
     NSTimer *_timer;
 }

 - (void)dealloc
 {
     NSLog(@"%s", __func__);
 }

 - (void)viewDidLoad
 {
     [super viewDidLoad];
     _timer = [NSTimer scheduledTimerWithTimeInterval:1
                                               target:self 
                                             selector:@selector(onTimeout) 
                                             userInfo:nil 
                                              repeats:YES];
 }

 - (void)onTimeout
 {
     NSLog(@"%s", __func__);
 }

 @end
</code></pre>

<p> 大家可能会觉得，当这个ViewController被 pop 掉后会正常释放，timer 也会停掉。但实际的情况不是你想的那样。以下log是Push这个ViewController后，然后点击返回的过程。</p>

<p> 2016-03-24 00:42:19.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:20.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:21.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:22.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 <strong>2016-03-24 00:42:23.369 NSTimerDemo[14916:3982566] -[TViewController viewDidDisappear:]</strong>
 2016-03-24 00:42:23.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:24.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]
 2016-03-24 00:42:25.663 NSTimerDemo[14916:3982566] -[TViewController onTimeout]</p>

<p> 从日志上来看，dealloc方法确实没有执行，而且timer事件还一直在触发。</p>

<p> OK,既然Timer强引用了ViewController，那把ViewController改成<strong>__weak</strong>不就是可以解决问题了？
 于是我们把创建Timer的代码改成</p>

<pre><code class="`"> __weak typeof(self) weak_self = self;
 _timer = [NSTimer scheduledTimerWithTimeInterval:1
                                           target:weak_self
                                         selector:@selector(onTimeout)
                                         userInfo:nil
                                          repeats:YES];
</code></pre>

<p> 发现输出的log和之前的一样，难道weak对象根本没起作用？
 用Instrement查看了一下内存情况，发现真的是Timer强引用Target对象</p>

<p> <img src="http://7xryar.com1.z0.glb.clouddn.com/NSTimer-Retain-Target.png" alt="Timer Retain Target" /></p>

<p> 目前主要是处于一个闭环（环形引用）的状态，我们要想办法打破这种状态，而且<strong>__weak</strong>设置给Timer也不会破坏Timer强引用Target。</p>

<p> 于是，我们引用一个包装对象，让Timer强引用这个包装对象，包装对象弱引用Target(ViewController)
 ViewController &mdash;> Timer &mdash;>Wrapper &hellip;>ViewController 这样就可以破坏环形引用。</p>

<pre><code class="`"> @Interface Wrapper
 @property (weak, nonatom) id target;
 @end
</code></pre>

<p> 那么创建Timer的类方法的Target对象不是传<code>self</code>, 而是传 wrapper 对象。
 另外，wrapper对象还要把Timer的事件传递到真正的target上。</p>

<p> 详细的 Timer Wrapper 可以看完代码 <a href="https://github.com/kaihaodir/BSUiKit/blob/master/BSTimer.h">BSTimer</a></p>

<p> 最后其实可以用dispatch_time解决强引用问题，但是dispatch_time在暂停功能上处理起来比较麻烦。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arc下NSException有可能会内存泄露]]></title>
    <link href="http://kaihaodir.github.io/blog/2016/03/13/arc-nsexception-cause-memory-leak/"/>
    <updated>2016-03-13T17:00:52+08:00</updated>
    <id>http://kaihaodir.github.io/blog/2016/03/13/arc-nsexception-cause-memory-leak</id>
    <content type="html"><![CDATA[<p>在使用Instrumnents对程序进行内存测试的时候，发现有几处异常处理的地方提示内存泄露。经过分析得知，<strong>因为异常处理，改变代码执行路径，导致编译生成的 release 代码没有执行</strong>。</p>

<!--more-->


<p>简单写了些测试代码验证：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad {
</span><span class='line'>    
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    
</span><span class='line'>    @try {
</span><span class='line'>        NSMutableArray *stringList = [[NSMutableArray alloc] init];
</span><span class='line'>        for (int i = 0; i &lt; 100; i++) {
</span><span class='line'>            [stringList addObject: @"string instance."];
</span><span class='line'>        }
</span><span class='line'>        [self throwException];
</span><span class='line'>    }
</span><span class='line'>    @catch (NSException *exception) {
</span><span class='line'>        NSLog(@"catch Exception : %@", exception);
</span><span class='line'>    }
</span><span class='line'>    @finally {
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)throwException
</span><span class='line'>{
</span><span class='line'>    [NSException raise:@"An Exception." format:@"Exception Description."];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>反复进出这个页面几次后，在Instruments上果然看到提示内存泄露，而且泄露的地方就指明是 <code>@try{ }</code> 里面创建的对象。</p>

<p><img src="http://7xryar.com1.z0.glb.clouddn.com/exception-memory-leak.png" alt="img" /></p>

<h4>解决思路</h4>

<p>1, 尽量不要在@try{}里面有操作，导致对象的引用引用计数增加。<code>@try{ }</code> 语句块里面只有有可能抛出异常的语句。</p>

<p><strong>修改后的代码:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad {
</span><span class='line'>    
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    
</span><span class='line'>    NSMutableArray *stringList = [[NSMutableArray alloc] init];
</span><span class='line'>    for (int i = 0; i &lt; 100; i++) {
</span><span class='line'>        [stringList addObject: @"string instance."];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    @try {
</span><span class='line'>        [self throwException];
</span><span class='line'>    }
</span><span class='line'>    @catch (NSException *exception) {
</span><span class='line'>        NSLog(@"catch Exception : %@", exception);
</span><span class='line'>    }
</span><span class='line'>    @finally {
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>最后用Instruments检查一下，一切正常了。</p>

<p>2, 查看了苹果的开发文档，发现有这么一段描述:</p>

<blockquote><pre><code>By default in Objective C, ARC is not exception-safe for normal releases:
It does not end the lifetime of __strong variables when their scopes are abnormally terminated by an exception.
It does not perform releases which would occur at the end of a full-expression if that full-expression throws an exception.
A program may be compiled with the option -fobjc-arc-exceptions in order to enable these, or with the option -fno-objc-arc-exceptions to explicitly disable them, with the last such argument “winning”.
</code></pre></blockquote>
]]></content>
  </entry>
  
</feed>
